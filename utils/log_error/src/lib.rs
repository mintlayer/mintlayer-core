// Copyright (c) 2021-2024 RBB S.r.l
// opensource@mintlayer.org
// SPDX-License-Identifier: MIT
// Licensed under the MIT License;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://github.com/mintlayer/mintlayer-core/blob/master/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use derive_more::Display;
use proc_macro::TokenStream;
use quote::quote;
use syn::{
    parse::{Parse, ParseStream},
    parse_quote,
    punctuated::Punctuated,
    Error, ItemFn, LitStr, ReturnType, Token,
};

/// A macro that logs errors returned by the function to which it is attached, mentioning
/// the location where the function was called.
///
/// Usage:
/// ```
/// # use log_error::log_error;
/// #[log_error]
/// fn my_func() -> std::io::Result<()> { // ...
/// # Ok(()) }
/// ```
/// The default logging level is `Error`, but it can also be specified explicitly as follows:
/// ```
/// # use log_error::log_error;
/// #[log_error(level = "debug")]
/// fn my_func() -> std::io::Result<()> { // ...
/// # Ok(()) }
/// ```
/// Possible values for the level are "trace", "debug", "info", "warn" and "error"
/// (case-insensitive).
///
/// # Interaction with `tracing::instrument`
///
/// Technically, you can specify `log_error` and `tracing::instrument` in any order, but the order
/// will determine whether the produced log line will contain `tracing`'s span info or not.
/// Namely, in this case the span info will be included:
/// ```
/// # use log_error::log_error;
/// #[log_error]
/// #[tracing::instrument]
/// fn my_func() -> std::io::Result<()> { // ...
/// # Ok(()) }
/// ```
/// but in this case it will be not:
/// ```
/// # use log_error::log_error;
/// #[tracing::instrument]
/// #[log_error]
/// fn my_func() -> std::io::Result<()> { // ...
/// # Ok(()) }
/// ```
/// This may seem counterintuitive, because the outer macro is called first and it should be
/// able to wrap whatever the inner macro is producing. But in reality `tracing::instrument`
/// wraps the body of the function and then puts all other attributes on top of it, so in the end
/// the code generated by `instrument` gets wrapped by `log_error`'s code and not vice versa.
///
/// # Other notes
///
/// 1. `tracing::instrument` has a similar feature, called `err`. E.g. the following will also log
/// errors returned by the function:
///    ```
///    #[tracing::instrument(err)]
///    fn my_func() -> std::io::Result<()> { // ...
///    # Ok(()) }
///    ```
///    This approach has downsides though:
///    -   The function call location is not logged.
///    -   `tracing::instrument` will always create a new span whenever it's used; there is no way
///        to say "I just want to log errors".
///        Also, the created span's info is not included in the error's log message, so it doesn't
///        help localize the error either.
///
/// 2. The implementation of `log_error` wraps the function body in a closure; this may lead to
/// compilation problems if the function's result captures a lifetime. E.g. consider this code:
///    ```ignore
///    struct R<'a>(&'a mut u8);
///
///    struct Test(u8);
///
///    impl Test {
///        #[log_error]
///        fn f(&mut self) -> std::io::Result<R<'_>> {
///            return Ok(R(&mut self.0))
///        }
///    }
///    ```
///    This will fail to compile with the error
///    *"captured variable cannot escape `FnMut` closure body"*.
///    In other circumstances a different error may be generated -
///    *"lifetime may not live long enough ... closure implements `Fn`,*
///    *so references to captured variables can't escape the closure"*.
///    Both errors seem to happen when mutable references are involved.
///
///    Note that `tracing::instrument(err)` has the same problem, see <https://github.com/tokio-rs/tracing/issues/2796>.
///
///    A possible workaround is to "capture" the mutable reference explicitly, e.g.:
///    ```
///    # use log_error::log_error;
///    # struct R<'a>(&'a mut u8);
///    # struct Test(u8);
///    impl Test {
///        #[log_error]
///        fn f(&mut self) -> std::io::Result<R<'_>> {
///            let this = self;
///            return Ok(R(&mut this.0))
///        }
///    }
///    ```
/// 3. For `async` functions, the implementation wraps the function body in an `async` block. This may also
/// lead to compilation problems if lifetimes are involved. E.g. this code:
///     ```ignore
///     struct Test<'a>(&'a u32);
///
///     impl<'a> Test<'a> {
///         #[log_error]
///         async fn f(&mut self) -> Result<(), std::io::Error> {
///             let val = self.0;
///             Ok(())
///         }
///     }
///     ```
///     will fail to compile with the error "hidden type `{async block@...}` captures the lifetime `'a`".
///
///     The workaround is to use the `async_fn_captures_lifetimes` attribute of `log_error`:
///     ```
///     # use log_error::log_error;
///     # struct Test<'a>(&'a u32);
///     impl<'a> Test<'a> {
///         #[log_error(async_fn_captures_lifetimes('a))]
///         async fn f(&mut self) -> Result<(), std::io::Error> {
///             let val = self.0;
///             Ok(())
///         }
///     }
///     ```
///     If there are more than one lifetime, separate them with commas:
///     ```ignore
///     #[log_error(async_fn_captures_lifetimes('a, 'b))]
///     ```
#[proc_macro_attribute]
pub fn log_error(args: TokenStream, item: TokenStream) -> TokenStream {
    let args = syn::parse_macro_input!(args as Args);
    let func = syn::parse_macro_input!(item as ItemFn);

    let log_level_str = args.level.unwrap_or(Level::Error).to_string();
    let log_level_tok: proc_macro2::TokenStream = log_level_str.parse().expect("Must succeed");

    let ItemFn {
        attrs,
        vis,
        sig,
        block,
    } = func;

    // Note: below we wrap the body of the function into a closure for two reasons:
    // 1) To support early returns.
    // 2) `#[track_caller]` has a peculiarity - if it's specified both for an outer and an inner
    // function, the caller location of the outer function will be propagated to the inner one.
    // This is not what we want; we want for functions marked with `#[log_error]` to print
    // the location of their immediate caller rather than some caller of the caller.
    // Fortunately,  wrapping a function call in a closure prevents the caller info from being
    // propagated.
    // See https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md#propagation-of-tracker

    let output = if sig.asyncness.is_none() {
        if args.async_fn_captures_lifetimes.is_some() {
            return syn::Error::new(
                proc_macro2::Span::call_site(),
                "The 'async_fn_captures_lifetimes' attribute only works for async functions",
            )
            .to_compile_error()
            .into();
        }

        quote! {
            #[track_caller]
            #(#attrs)*
            #vis #sig {
                let result = (move || #block)();

                if let Err(ref err) = result {
                    utils::mintlayer_core_log_error_support::log(
                        err,
                        "log_error",
                        utils::mintlayer_core_log_error_support::Level::#log_level_tok,
                        std::panic::Location::caller()
                    );
                }
                result
            }
        }
    } else {
        let captures_lifetimes = args
            .async_fn_captures_lifetimes
            .unwrap_or_default()
            .0
            .iter()
            .cloned()
            .collect::<Vec<_>>();

        // "track_caller" won't work in an async function, it has to be re-written as non-async
        // one returning `impl Future`.
        let mut sig = sig;
        sig.asyncness = None;
        sig.output = match sig.output {
            ReturnType::Default => {
                parse_quote! { -> impl std::future::Future<Output = () > }
            }
            ReturnType::Type(_, ret_type) => {
                parse_quote! { -> impl std::future::Future<Output = #ret_type > }
            }
        };

        // Note about the "fix_hidden_lifetime_bug" call:
        // Rewriting an async function as a non async one that returns `impl Future`
        // isn't always straightforward. E.g. consider this function:
        //      async fn a_func(x: &str, y: &str) {
        //          // Use x and y somehow.
        //          x.to_owned();
        //          y.to_owned();
        //      }
        // If you rewrite it as follows:
        //      fn func(x: &str, y: &str) -> impl Future<Output = ()> {
        //          async move {
        //             x.to_owned();
        //             y.to_owned();
        //          }
        //      }
        // you'll get the error: "hidden type for `impl Future<Output = ()>` captures lifetime
        // that does not appear in bounds".
        // The solution here is to introduce something like this:
        //      trait Captures<'a> { }
        //      impl<T: ?Sized> Captures<'a> for T { }
        // and re-write "func" as follows:
        //      fn func<'a, 'b>(x: &'a str, y: &'b str) ->
        //          impl Future<Output = ()> + Captures<(&'a (), &'b ())> { ...
        // And this is basically what "fix_hidden_lifetime_bug" does.
        //
        // P.S.: "hidden lifetime bug" refers to the issue https://github.com/rust-lang/rust/issues/63033
        // where async functions would fail to compile with the aforementioned "hidden type ...
        // captures lifetime" error. That issue has been fixed in 1.69, but non-async functions
        // that return `impl Future` still need this workaround as of Rust 1.76.
        //
        // Also note that we re-use `fix_hidden_lifetime_bug` machinery to handle the `async_fn_captures_lifetimes`
        // attribute too.
        quote! {
            #[track_caller]
            #[utils::mintlayer_core_log_error_support::fix_hidden_lifetime_bug::fix_hidden_lifetime_bug(
                // Note: this makes `fix_hidden_lifetime_bug` refer to itself via this name.
                crate=utils::mintlayer_core_log_error_support::fix_hidden_lifetime_bug
            )]
            #(#attrs)*
            #vis #sig #( + utils::mintlayer_core_log_error_support::fix_hidden_lifetime_bug::Captures<#captures_lifetimes>)*  {
                // For some weird reason, if `Location::caller` is called inside the async block,
                // it will contain the location where the macro is called (probably, the location
                // of the async block itself). So we have to call it outside the block before
                // we have a chance to check for error.
                let caller_location = std::panic::Location::caller();
                async move {
                    let result = (
                        move || {
                            // Need to put the block into an async block directly, so that `await`
                            // works.
                            async move { #block }
                        }
                    )().await;

                    if let Err(ref err) = result {
                        utils::mintlayer_core_log_error_support::log(
                            err,
                            "log_error",
                            utils::mintlayer_core_log_error_support::Level::#log_level_tok,
                            caller_location
                        );
                    }

                    result
                }
            }
        }
    };

    TokenStream::from(output)
}

#[derive(Display)]
enum Level {
    Trace,
    Debug,
    Info,
    Error,
    Warn,
}

#[derive(Default)]
struct CapturesLifetimes(Punctuated<syn::Lifetime, Token![,]>);

impl Parse for Level {
    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
        let _ = input.parse::<kw::level>()?;
        let _ = input.parse::<Token![=]>()?;
        let str: LitStr = input.parse()?;
        match str.value() {
            s if s.eq_ignore_ascii_case("trace") => Ok(Level::Trace),
            s if s.eq_ignore_ascii_case("debug") => Ok(Level::Debug),
            s if s.eq_ignore_ascii_case("info") => Ok(Level::Info),
            s if s.eq_ignore_ascii_case("warn") => Ok(Level::Warn),
            s if s.eq_ignore_ascii_case("error") => Ok(Level::Error),
            _ => Err(Error::new(
                input.cursor().span(),
                "unknown verbosity level; expected one of \"trace\", \"debug\", \"info\", \
                    \"warn\", or \"error\" (case-insensitive)",
            )),
        }
    }
}

impl Parse for CapturesLifetimes {
    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
        let _ = input.parse::<kw::async_fn_captures_lifetimes>();
        let content;
        let _ = syn::parenthesized!(content in input);
        let lifetimes = content.parse_terminated(syn::Lifetime::parse, Token![,])?;
        Ok(Self(lifetimes))
    }
}

#[derive(Default)]
struct Args {
    level: Option<Level>,
    async_fn_captures_lifetimes: Option<CapturesLifetimes>,
}

impl Parse for Args {
    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
        let mut args = Self::default();

        while !input.is_empty() {
            let lookahead = input.lookahead1();

            if lookahead.peek(kw::level) {
                if args.level.is_some() {
                    return Err(input.error("duplicate `level` argument"));
                }
                args.level = Some(input.parse()?);
            } else if lookahead.peek(kw::async_fn_captures_lifetimes) {
                if args.async_fn_captures_lifetimes.is_some() {
                    return Err(input.error("duplicate `async_fn_captures_lifetimes` argument"));
                }
                args.async_fn_captures_lifetimes = Some(input.parse()?);
            } else if lookahead.peek(Token![,]) {
                let _ = input.parse::<Token![,]>()?;
            } else {
                return Err(lookahead.error());
            }
        }

        Ok(args)
    }
}

mod kw {
    syn::custom_keyword!(level);
    syn::custom_keyword!(async_fn_captures_lifetimes);
}
