name: Release

permissions:
  contents: write

on:
  push:
    tags:
      - '**[0-9]+.[0-9]+.[0-9]+*'
  pull_request:

jobs:
  plan:
    runs-on: ubuntu-latest
    outputs:
      val: ${{ steps.plan.outputs.manifest }}
      tag: ${{ !github.event.pull_request && github.ref_name || '' }}
      tag-flag: ${{ !github.event.pull_request && format('--tag={0}', github.ref_name) || '' }}
      publishing: ${{ !github.event.pull_request }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install cargo-dist
        shell: bash
        run: "curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.8.0/cargo-dist-installer.sh | sh"
      - id: plan
        run: |
          cargo dist ${{ !github.event.pull_request && format('host --steps=create --tag={0}', github.ref_name) || (github.event.pull_request.head.repo.fork && 'plan' || 'host --steps=check') }} --output-format=json > dist-manifest.json
          echo "cargo dist ran successfully"
          cat dist-manifest.json
          echo "manifest=$(jq -c "." dist-manifest.json)" >> "$GITHUB_OUTPUT"
      - name: "Upload dist-manifest.json"
        uses: actions/upload-artifact@v4
        with:
          name: dist-manifest-${{ github.run_id }}
          path: dist-manifest.json
  build-macos:
    runs-on: macos-latest
    needs: plan
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
    - name: Set up Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        targets: aarch64-apple-darwin, x86_64-apple-darwin
    - name: Add x86_64 target
      run: rustup target add x86_64-apple-darwin
    - name: Build Release (ARM64)
      run: cargo build --release --bin node-gui --target aarch64-apple-darwin
    - name: Build Release (x86_64)
      run: cargo build --release --bin node-gui --target x86_64-apple-darwin
    - name: Create Universal Binary
      run: |
        lipo -create -output target/release/node-gui-universal \
          target/aarch64-apple-darwin/release/node-gui \
          target/x86_64-apple-darwin/release/node-gui
    - name: Install create-dmg
      run: brew install create-dmg
    - name: Create App Bundle
      run: |
        mkdir -p target/release/bundle/osx/Mintlayer\ Node\ GUI.app/Contents/MacOS
        mkdir -p target/release/bundle/osx/Mintlayer\ Node\ GUI.app/Contents/Resources
        cp target/release/node-gui-universal target/release/bundle/osx/Mintlayer\ Node\ GUI.app/Contents/MacOS/node-gui
        cp logo.icns target/release/bundle/osx/Mintlayer\ Node\ GUI.app/Contents/Resources/
    - name: Generate Info.plist
      run: |
        VERSION=$(cargo metadata --format-version 1 | jq -r '.packages[] | select(.name == "node-gui") | .version')
        BUILD_NUMBER=$(date +%Y%m%d.%H%M%S)
        sed -e "s/VERSION_PLACEHOLDER/$VERSION/g" -e "s/BUILD_PLACEHOLDER/$BUILD_NUMBER/g" build-tools/osx/Info.plist.template > target/release/bundle/osx/Mintlayer\ Node\ GUI.app/Contents/Info.plist
    - name: Install the Apple certificate
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create variables
        CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.cer
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        # Import certificate from secrets
        echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode --output $CERTIFICATE_PATH
        # Create temporary keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        # Convert certificate to PEM format
        openssl x509 -in $CERTIFICATE_PATH -inform DER -out $RUNNER_TEMP/build_certificate.pem -outform PEM
        # Import certificate to keychain
        security import $RUNNER_TEMP/build_certificate.pem -k $KEYCHAIN_PATH -T /usr/bin/codesign
        # Debug: List all certificates in the keychain
        security find-certificate -a $KEYCHAIN_PATH
        # Set keychain search list
        security list-keychains -d user -s $KEYCHAIN_PATH $(security list-keychains -d user | sed s/\"//g)
        # Make the keychain the default
        security default-keychain -s $KEYCHAIN_PATH
        # Unlock the keychain
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        # Allow codesign to access the keychain
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        # Debug: Try to find the certificate
        security find-certificate -c "Developer ID Application" $KEYCHAIN_PATH
        # Clean up
        rm $CERTIFICATE_PATH
        rm $RUNNER_TEMP/build_certificate.pem
        # Final debug: List keychains and their status
        security list-keychains
        security default-keychain
        security show-keychain-info $KEYCHAIN_PATH
    - name: Code Sign
      env:
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}  
      run: |
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $RUNNER_TEMP/app-signing.keychain-db
        /usr/bin/codesign --force -s "${{ secrets.CERTIFICATE_NAME }}" --options runtime --timestamp target/release/bundle/osx/Mintlayer\ Node\ GUI.app -v
    - name: Create DMG
      run: |
        create-dmg \
          --volname "Mintlayer Node GUI" \
          --window-pos 200 120 \
          --window-size 600 400 \
          --icon-size 100 \
          --icon "Mintlayer Node GUI.app" 175 120 \
          --hide-extension "Mintlayer Node GUI.app" \
          --app-drop-link 425 120 \
          "Mintlayer_Node_GUI.dmg" \
          "target/release/bundle/osx/"
          
    - name: Notarize and Staple DMG
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
      run: |
        # Submit for notarization
        NOTARIZATION_OUTPUT=$(xcrun notarytool submit Mintlayer_Node_GUI.dmg --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM_ID" --password "$APPLE_ID_PASSWORD" --wait)
        echo "$NOTARIZATION_OUTPUT"

        # Extract submission ID
        SUBMISSION_ID=$(echo "$NOTARIZATION_OUTPUT" | grep -o 'id: [a-f0-9-]\+' | cut -d' ' -f2)

        if [ -z "$SUBMISSION_ID" ]; then
          echo "Failed to extract submission ID. Notarization may have failed."
          echo "$NOTARIZATION_OUTPUT"
          exit 1
        fi

        echo "Notarization submission ID: $SUBMISSION_ID"

        # Check notarization status in a loop
        for i in {1..30}; do
          STATUS_OUTPUT=$(xcrun notarytool info "$SUBMISSION_ID" --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM_ID" --password "$APPLE_ID_PASSWORD")
          echo "$STATUS_OUTPUT"

          if echo "$STATUS_OUTPUT" | grep -q "status: Accepted"; then
            echo "Notarization successful. Proceeding to staple."
            xcrun stapler staple Mintlayer_Node_GUI.dmg
            echo "Stapling complete."
            break
          elif echo "$STATUS_OUTPUT" | grep -q "status: Invalid"; then
            echo "Notarization failed. Check status output for details."
            exit 1
          else
            echo "Notarization still in progress. Waiting 60 seconds before checking again."
            sleep 60
          fi

          if [ $i -eq 30 ]; then
            echo "Notarization timed out after 30 attempts. Check status manually."
            exit 1
          fi
        done

    - name: Verify Notarization
      run: |
        spctl -a -vvv -t install Mintlayer_Node_GUI.dmg
    - name: Upload DMG Artifact
      uses: actions/upload-artifact@v4
      with:
        name: macos-universal-dmg-${{ github.run_id }}
        path: Mintlayer_Node_GUI.dmg
    - name: Upload Notarization Logs
      uses: actions/upload-artifact@v4
      with:
        name: notarization-logs-${{ github.run_id }}
        path: |
          notarization_output.txt
          status_output.txt

  build-local-artifacts:
    name: build-local-artifacts (${{ join(matrix.targets, ', ') }})
    needs:
      - plan
    if: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix.include != null && (needs.plan.outputs.publishing == 'true' || fromJson(needs.plan.outputs.val).ci.github.pr_run_mode == 'upload') }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.plan.outputs.val).ci.github.artifacts_matrix }}
    runs-on: ${{ matrix.runner }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: target/distrib/${{ join(matrix.targets, '-') }}-dist-manifest.json
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - uses: swatinem/rust-cache@v2
      - name: Install cargo-dist
        run: ${{ matrix.install_dist }}
      - name: Fetch local artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist-manifest-${{ github.run_id }}
          path: target/distrib/
      - name: Install dependencies
        run: |
          ${{ matrix.packages_install }}
      - name: Build artifacts
        run: |
          cargo dist build ${{ needs.plan.outputs.tag-flag }} --print=linkage --output-format=json ${{ matrix.dist_args }} > dist-manifest.json
          echo "cargo dist ran successfully"
      - id: cargo-dist
        name: Post-build
        shell: bash
        run: |
          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
          jq --raw-output ".artifacts[]?.path | select( . != null )" dist-manifest.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          cp dist-manifest.json "$BUILD_MANIFEST_NAME"
      - name: "Upload artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: dist-artifacts-${{ join(matrix.targets, '-') }}-${{ github.run_id }}
          path: |
            ${{ steps.cargo-dist.outputs.paths }}
            ${{ env.BUILD_MANIFEST_NAME }}

  build-global-artifacts:
    needs:
      - plan
      - build-local-artifacts
    runs-on: "ubuntu-20.04"
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      BUILD_MANIFEST_NAME: target/distrib/global-dist-manifest.json
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install cargo-dist
        run: "curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.8.0/cargo-dist-installer.sh | sh"
      - name: Fetch local artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist-manifest-${{ github.run_id }}
          path: target/distrib/
      - id: cargo-dist
        shell: bash
        run: |
          cargo dist build ${{ needs.plan.outputs.tag-flag }} --output-format=json "--artifacts=global" > dist-manifest.json
          echo "cargo dist ran successfully"

          echo "paths<<EOF" >> "$GITHUB_OUTPUT"
          jq --raw-output ".artifacts[]?.path | select( . != null )" dist-manifest.json >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

          cp dist-manifest.json "$BUILD_MANIFEST_NAME"
      - name: "Upload artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: dist-artifacts-global-${{ github.run_id }}
          path: |
            ${{ steps.cargo-dist.outputs.paths }}
            ${{ env.BUILD_MANIFEST_NAME }}

  host:
    needs:
      - plan
      - build-local-artifacts
      - build-global-artifacts
    if: ${{ always() && needs.plan.outputs.publishing == 'true' && (needs.build-global-artifacts.result == 'skipped' || needs.build-global-artifacts.result == 'success') && (needs.build-local-artifacts.result == 'skipped' || needs.build-local-artifacts.result == 'success') }}
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    runs-on: "ubuntu-20.04"
    outputs:
      val: ${{ steps.host.outputs.manifest }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Install cargo-dist
        run: "curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/download/v0.8.0/cargo-dist-installer.sh | sh"
      - name: Fetch artifacts
        uses: actions/download-artifact@v4
        with:
          path: target/distrib/
      - id: host
        shell: bash
        run: |
          cargo dist host ${{ needs.plan.outputs.tag-flag }} --steps=upload --steps=release --output-format=json > dist-manifest.json
          echo "artifacts uploaded and released successfully"
          cat dist-manifest.json
          echo "manifest=$(jq -c "." dist-manifest.json)" >> "$GITHUB_OUTPUT"
      - name: "Upload dist-manifest.json"
        uses: actions/upload-artifact@v4
        with:
          name: final-dist-manifest-${{ github.run_id }}
          path: dist-manifest.json

  publish-homebrew-formula:
    needs:
      - plan
      - host
    runs-on: "ubuntu-20.04"
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      PLAN: ${{ needs.plan.outputs.val }}
      GITHUB_USER: "Mintlayer CI"
      GITHUB_EMAIL: "devs@mintlayer.org"
      # if: ${{ !fromJson(needs.plan.outputs.val).announcement_is_prerelease || fromJson(needs.plan.outputs.val).publish_prereleases }}
    if: false
    steps:
      - uses: actions/checkout@v4
        with:
          repository: "mintlayer/homebrew"
          token: ${{ secrets.HOMEBREW_TAP_TOKEN }}
      - name: Fetch local artifacts
        uses: actions/download-artifact@v4
        with:
          name: final-dist-manifest-${{ github.run_id }}
          path: Formula/
      - name: Commit formula files
        run: |
          git config --global user.name "${GITHUB_USER}"
          git config --global user.email "${GITHUB_EMAIL}"

          for release in $(echo "$PLAN" | jq --compact-output '.releases[]'); do
            name=$(echo "$release" | jq .app_name --raw-output)
            version=$(echo "$release" | jq .app_version --raw-output)
            formula_file="Formula/${name}.rb"

            if [ -f "$formula_file" ]; then
              git add "$formula_file"
            else
              echo "Warning: Formula file $formula_file not found. Skipping."
            fi
            git commit -m "${name} ${version}"
          done
          git push

  announce:
    needs:
      - plan
      - host
      - publish-homebrew-formula
      - build-macos
    if: ${{ always() && needs.host.result == 'success' && (needs.publish-homebrew-formula.result == 'skipped' || needs.publish-homebrew-formula.result == 'success') && needs.build-macos.result == 'success' }}
    runs-on: "ubuntu-20.04"
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: "Download All Artifacts"
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts
      - name: Prepare Release Assets
        run: |
          mkdir -p release-assets
          find all-artifacts -type f -not -name '*-dist-manifest.json' -exec cp {} release-assets/ \;
      - name: Create Github Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.plan.outputs.tag }}
          name: ${{ fromJson(needs.host.outputs.val).announcement_title }}
          body: ${{ fromJson(needs.host.outputs.val).announcement_github_body }}
          prerelease: ${{ fromJson(needs.host.outputs.val).announcement_is_prerelease }}
          artifacts: "release-assets/*"