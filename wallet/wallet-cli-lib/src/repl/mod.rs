// Copyright (c) 2023 RBB S.r.l
// opensource@mintlayer.org
// SPDX-License-Identifier: MIT
// Licensed under the MIT License;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://github.com/mintlayer/mintlayer-core/blob/master/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pub mod interactive;
pub mod non_interactive;

use clap::{Command, FromArgMatches, Subcommand};
use tokio::sync::mpsc;

use crate::{
    cli_event_loop::Event,
    commands::{ConsoleCommand, WalletCommand},
    errors::WalletCliError,
};

// Strip out usage
const MAIN_HELP_TEMPLATE: &str = "\
    {all-args}
";

// Strip out name/version
const COMMAND_HELP_TEMPLATE: &str = "\
    {about-with-newline}\n\
    {usage-heading}\n    {usage}\n\
    \n\
    {all-args}{after-help}\
";

pub fn get_repl_command() -> Command {
    let repl_command = Command::new("repl")
        .multicall(true)
        .arg_required_else_help(true)
        .subcommand_required(true)
        .subcommand_value_name("Command")
        .subcommand_help_heading("Commands")
        .help_template(MAIN_HELP_TEMPLATE);

    // Add commands from generated by clap-derive
    let mut repl_command = WalletCommand::augment_subcommands(repl_command);

    // Customize the help template for all commands to make it more REPL friendly
    for subcommand in repl_command.get_subcommands_mut() {
        *subcommand = subcommand.clone().help_template(COMMAND_HELP_TEMPLATE);
    }

    repl_command
}

/// Try to parse REPL input string as a [WalletCommands]
fn parse_input(
    line: &str,
    repl_command: &Command,
) -> Result<Option<WalletCommand>, WalletCliError> {
    let line = line.trim();
    if line.is_empty() || line.starts_with('#') {
        return Ok(None);
    }
    // Split arguments as a normal shell would do
    let args = shlex::split(line).ok_or(WalletCliError::InvalidQuoting)?;
    let mut matches = repl_command
        .clone()
        .try_get_matches_from(args)
        .map_err(WalletCliError::InvalidCommandInput)?;
    let command = WalletCommand::from_arg_matches_mut(&mut matches)
        .map_err(WalletCliError::InvalidCommandInput)?;
    Ok(Some(command))
}

fn run_command_blocking(
    event_tx: &mpsc::UnboundedSender<Event>,
    command: WalletCommand,
) -> Result<ConsoleCommand, WalletCliError> {
    let (res_tx, res_rx) = tokio::sync::oneshot::channel();
    event_tx.send(Event::HandleCommand { command, res_tx }).expect("Channel must be open");
    res_rx.blocking_recv().expect("Channel must be open")
}
